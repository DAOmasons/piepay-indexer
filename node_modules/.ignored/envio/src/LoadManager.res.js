// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Utils = require("./Utils.res.js");
var Internal = require("./Internal.res.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var Call = {};

var Group = {};

function make() {
  return {
          groups: {},
          isCollecting: false
        };
}

async function schedule(loadManager) {
  loadManager.isCollecting = true;
  await Promise.resolve();
  loadManager.isCollecting = false;
  var groups = loadManager.groups;
  Object.keys(groups).forEach(async function (key) {
        var group = groups[key];
        var calls = group.calls;
        var inputsToLoad = [];
        var currentInputKeys = [];
        Object.keys(calls).forEach(function (inputKey) {
              var call = calls[inputKey];
              if (!call.isLoading) {
                call.isLoading = true;
                currentInputKeys.push(inputKey);
                if (!group.hasInMemory(inputKey)) {
                  inputsToLoad.push(call.input);
                  return ;
                } else {
                  return ;
                }
              }
              
            });
        if (!Utils.$$Array.isEmpty(inputsToLoad)) {
          try {
            await group.load(inputsToLoad);
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            var exn$1 = Internal.prettifyExn(exn);
            Belt_Array.forEach(currentInputKeys, (function (inputKey) {
                    var call = calls[inputKey];
                    call.reject(exn$1);
                  }));
          }
        }
        if (Utils.$$Array.isEmpty(currentInputKeys)) {
          return ;
        }
        currentInputKeys.forEach(function (inputKey) {
              var call = calls[inputKey];
              Utils.Dict.deleteInPlace(calls, inputKey);
              call.resolve(group.getUnsafeInMemory(inputKey));
            });
        var latestGroup = groups[key];
        if (Utils.$$Array.isEmpty(Object.keys(latestGroup.calls))) {
          return Utils.Dict.deleteInPlace(groups, key);
        }
        
      });
}

function noopHasher(input) {
  return input;
}

function call(loadManager, input, key, load, hasher, shouldGroup, hasInMemory, getUnsafeInMemory) {
  var inputKey = hasher === noopHasher ? input : hasher(input);
  if (!shouldGroup && hasInMemory(inputKey)) {
    return Promise.resolve(getUnsafeInMemory(inputKey));
  }
  var group = loadManager.groups[key];
  var group$1;
  if (group !== undefined) {
    group$1 = group;
  } else {
    var g_calls = {};
    var g = {
      calls: g_calls,
      load: load,
      getUnsafeInMemory: getUnsafeInMemory,
      hasInMemory: hasInMemory
    };
    loadManager.groups[key] = g;
    group$1 = g;
  }
  var c = group$1.calls[inputKey];
  if (c !== undefined) {
    return c.promise;
  }
  var promise = new Promise((function (resolve, reject) {
          var call = {
            input: input,
            resolve: resolve,
            reject: reject,
            promise: null,
            isLoading: false
          };
          group$1.calls[inputKey] = call;
        }));
  group$1.calls[inputKey].promise = promise;
  if (!loadManager.isCollecting) {
    schedule(loadManager);
  }
  return promise;
}

exports.Call = Call;
exports.Group = Group;
exports.make = make;
exports.schedule = schedule;
exports.noopHasher = noopHasher;
exports.call = call;
/* Utils Not a pure module */
