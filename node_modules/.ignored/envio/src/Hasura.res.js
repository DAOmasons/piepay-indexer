// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Rest = require("./vendored/Rest.res.js");
var Table = require("./db/Table.res.js");
var Utils = require("./Utils.res.js");
var Schema = require("./db/Schema.res.js");
var Logging = require("./Logging.res.js");
var Internal = require("./Internal.res.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");
var S$RescriptSchema = require("rescript-schema/src/S.res.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

function auth(s) {
  return {
          role: s.header("X-Hasura-Role", S$RescriptSchema.string),
          secret: s.header("X-Hasura-Admin-Secret", S$RescriptSchema.string)
        };
}

var responses = [
  (function (s) {
      s.status(200);
      s.data(S$RescriptSchema.unknown);
      return "QuerySucceeded";
    }),
  (function (s) {
      s.field("code", S$RescriptSchema.$$enum([
                "already-exists",
                "already-tracked"
              ]));
      return "AlreadyDone";
    })
];

function clearMetadataRoute() {
  return {
          method: "POST",
          path: "",
          input: (function (s) {
              s.field("type", S$RescriptSchema.literal("clear_metadata"));
              s.field("args", S$RescriptSchema.literal({}));
              return auth(s);
            }),
          responses: responses
        };
}

function trackTablesRoute() {
  return {
          method: "POST",
          path: "",
          input: (function (s) {
              s.field("type", S$RescriptSchema.literal("pg_track_tables"));
              return {
                      args: s.field("args", S$RescriptSchema.json(false)),
                      auth: auth(s)
                    };
            }),
          responses: responses
        };
}

function createSelectPermissionRoute() {
  return {
          method: "POST",
          path: "",
          input: (function (s) {
              s.field("type", S$RescriptSchema.literal("pg_create_select_permission"));
              return {
                      args: s.field("args", S$RescriptSchema.json(false)),
                      auth: auth(s)
                    };
            }),
          responses: responses
        };
}

function rawBodyRoute() {
  return {
          method: "POST",
          path: "",
          input: (function (s) {
              return {
                      bodyString: s.rawBody(S$RescriptSchema.string),
                      auth: auth(s)
                    };
            }),
          responses: responses
        };
}

async function clearHasuraMetadata(endpoint, auth) {
  try {
    var result = await Rest.$$fetch(clearMetadataRoute, auth, Rest.client(endpoint, undefined));
    var msg;
    msg = result === "QuerySucceeded" ? "Metadata Cleared" : "Metadata Already Cleared";
    return Logging.trace(msg);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return Logging.error({
                msg: "EE806: There was an issue clearing metadata in hasura - indexing may still work - but you may have issues querying the data in hasura.",
                err: Internal.prettifyExn(exn)
              });
  }
}

async function trackTables(endpoint, auth, pgSchema, tableNames) {
  try {
    var result = await Rest.$$fetch(trackTablesRoute, {
          auth: auth,
          args: {
            allow_warnings: false,
            tables: tableNames.map(function (tableName) {
                  return {
                          table: {
                            name: tableName,
                            schema: pgSchema
                          },
                          configuration: {
                            custom_name: tableName
                          }
                        };
                })
          }
        }, Rest.client(endpoint, undefined));
    var msg;
    msg = result === "QuerySucceeded" ? "Tables Tracked" : "Table Already Tracked";
    return Logging.trace({
                msg: msg,
                tableNames: tableNames
              });
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return Logging.error({
                msg: "EE807: There was an issue tracking tables in hasura - indexing may still work - but you may have issues querying the data in hasura.",
                tableNames: tableNames,
                err: Internal.prettifyExn(exn)
              });
  }
}

async function createSelectPermissions(auth, endpoint, tableName, pgSchema, responseLimit, aggregateEntities) {
  try {
    var result = await Rest.$$fetch(createSelectPermissionRoute, {
          auth: auth,
          args: {
            table: {
              schema: pgSchema,
              name: tableName
            },
            role: "public",
            source: "default",
            permission: {
              columns: "*",
              filter: {},
              limit: responseLimit,
              allow_aggregations: aggregateEntities.includes(tableName)
            }
          }
        }, Rest.client(endpoint, undefined));
    var msg;
    msg = result === "QuerySucceeded" ? "Hasura select permissions created" : "Hasura select permissions already created";
    return Logging.trace({
                msg: msg,
                tableName: tableName
              });
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return Logging.error({
                msg: "EE808: There was an issue setting up view permissions for the " + tableName + " table in hasura - indexing may still work - but you may have issues querying the data in hasura.",
                tableName: tableName,
                err: Internal.prettifyExn(exn)
              });
  }
}

async function createEntityRelationship(pgSchema, endpoint, auth, tableName, relationshipType, relationalKey, objectName, mappedEntity, isDerivedFrom) {
  var derivedFromTo = isDerivedFrom ? "\"id\": \"" + relationalKey + "\"" : "\"" + relationalKey + "_id\" : \"id\"";
  var bodyString = "{\"type\": \"pg_create_" + relationshipType + "_relationship\",\"args\": {\"table\": {\"schema\": \"" + pgSchema + "\", \"name\": \"" + tableName + "\"},\"name\": \"" + objectName + "\",\"source\": \"default\",\"using\": {\"manual_configuration\": {\"remote_table\": {\"schema\": \"" + pgSchema + "\", \"name\": \"" + mappedEntity + "\"},\"column_mapping\": {" + derivedFromTo + "}}}}}";
  try {
    var result = await Rest.$$fetch(rawBodyRoute, {
          auth: auth,
          bodyString: bodyString
        }, Rest.client(endpoint, undefined));
    var msg;
    msg = result === "QuerySucceeded" ? "Hasura " + relationshipType + " relationship created" : "Hasura " + relationshipType + " relationship already created";
    return Logging.trace({
                msg: msg,
                tableName: tableName
              });
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return Logging.error({
                msg: "EE808: There was an issue setting up " + relationshipType + " relationship for the " + tableName + " table in hasura - indexing may still work - but you may have issues querying the data in hasura.",
                tableName: tableName,
                err: Internal.prettifyExn(exn)
              });
  }
}

async function trackDatabase(endpoint, auth, pgSchema, allStaticTables, allEntityTables, aggregateEntities, responseLimit, schema) {
  Logging.info("Tracking tables in Hasura");
  await clearHasuraMetadata(endpoint, auth);
  var tableNames = Belt_Array.concatMany([
          allStaticTables,
          allEntityTables
        ]).map(function (param) {
        return param.tableName;
      });
  await trackTables(endpoint, auth, pgSchema, tableNames);
  await Promise.all(Caml_splice_call.spliceObjApply(tableNames.map(function (tableName) {
                return createSelectPermissions(auth, endpoint, tableName, pgSchema, responseLimit, aggregateEntities);
              }), "concat", [allEntityTables.map(function (table) {
                  var tableName = table.tableName;
                  return [
                            Table.getDerivedFromFields(table).map(function (derivedFromField) {
                                  var relationalFieldName = Utils.unwrapResultExn(Schema.getDerivedFromFieldName(schema, derivedFromField));
                                  return createEntityRelationship(pgSchema, endpoint, auth, tableName, "array", relationalFieldName, derivedFromField.fieldName, derivedFromField.derivedFromEntity, true);
                                }),
                            Table.getLinkedEntityFields(table).map(function (param) {
                                  var field = param[0];
                                  return createEntityRelationship(pgSchema, endpoint, auth, tableName, "object", field.fieldName, field.fieldName, param[1], false);
                                })
                          ].flat(1);
                })]));
}

exports.auth = auth;
exports.responses = responses;
exports.clearMetadataRoute = clearMetadataRoute;
exports.trackTablesRoute = trackTablesRoute;
exports.createSelectPermissionRoute = createSelectPermissionRoute;
exports.rawBodyRoute = rawBodyRoute;
exports.clearHasuraMetadata = clearHasuraMetadata;
exports.trackTables = trackTables;
exports.createSelectPermissions = createSelectPermissions;
exports.createEntityRelationship = createEntityRelationship;
exports.trackDatabase = trackDatabase;
/* Rest Not a pure module */
