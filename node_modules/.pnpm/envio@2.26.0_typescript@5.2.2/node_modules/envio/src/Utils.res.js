// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("rescript/lib/js/array.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");
var S$RescriptSchema = require("rescript-schema/src/S.res.js");

function delay(milliseconds) {
  return new Promise((function (resolve, param) {
                setTimeout((function () {
                        resolve();
                      }), milliseconds);
              }));
}

var $$Object = {};

var $$Error = {};

function mapNone(opt, val) {
  if (opt !== undefined) {
    return ;
  } else {
    return Caml_option.some(val);
  }
}

function catchToNone(unsafeFunc) {
  try {
    return Caml_option.some(unsafeFunc());
  }
  catch (exn){
    return ;
  }
}

function flatten(opt) {
  if (opt !== undefined) {
    return Caml_option.valFromOption(opt);
  }
  
}

function getExn(opt, message) {
  if (opt !== undefined) {
    return Caml_option.valFromOption(opt);
  } else {
    return Js_exn.raiseError(message);
  }
}

var $$Option = {
  mapNone: mapNone,
  catchToNone: catchToNone,
  flatten: flatten,
  getExn: getExn
};

function get(tuple, index) {
  return (tuple[index]);
}

var Tuple = {
  get: get
};

var has = ((dict, key) => key in dict);

function push(dict, key, value) {
  var arr = dict[key];
  if (arr !== undefined) {
    arr.push(value);
  } else {
    dict[key] = [value];
  }
}

function pushMany(dict, key, values) {
  var arr = dict[key];
  if (arr !== undefined) {
    Caml_splice_call.spliceObjApply(arr, "push", [values]);
  } else {
    dict[key] = values;
  }
}

var merge = ((dictA, dictB) => ({...dictA, ...dictB}));

function map(dict, fn) {
  var newDict = {};
  var keys = Object.keys(dict);
  for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
    var key = keys[idx];
    newDict[key] = fn(dict[key]);
  }
  return newDict;
}

function forEach(dict, fn) {
  var keys = Object.keys(dict);
  for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
    fn(dict[keys[idx]]);
  }
}

function forEachWithKey(dict, fn) {
  var keys = Object.keys(dict);
  for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
    var key = keys[idx];
    fn(key, dict[key]);
  }
}

var deleteInPlace = ((dict, key) => {
      delete dict[key];
    });

var updateImmutable = ((dict, key, value) => ({...dict, [key]: value}));

var shallowCopy = ((dict) => ({...dict}));

function size(dict) {
  return Object.keys(dict).length;
}

var Dict = {
  has: has,
  push: push,
  pushMany: pushMany,
  merge: merge,
  map: map,
  forEach: forEach,
  forEachWithKey: forEachWithKey,
  deleteInPlace: deleteInPlace,
  updateImmutable: updateImmutable,
  shallowCopy: shallowCopy,
  size: size
};

function minOptInt(a, b) {
  if (a === undefined) {
    if (b !== undefined) {
      return Caml_option.some(Caml_option.valFromOption(b));
    } else {
      return ;
    }
  }
  var a$1 = Caml_option.valFromOption(a);
  if (b !== undefined) {
    return Caml_option.some(Caml_obj.min(a$1, Caml_option.valFromOption(b)));
  } else {
    return Caml_option.some(a$1);
  }
}

var $$Math = {
  minOptInt: minOptInt
};

function mergeSorted(f, xs, ys) {
  if (xs.length === 0) {
    return ys;
  }
  if (ys.length === 0) {
    return xs;
  }
  var n = xs.length + ys.length | 0;
  var result = Array(n);
  var loop = function (_i, _j, _k) {
    while(true) {
      var k = _k;
      var j = _j;
      var i = _i;
      if (i < xs.length && j < ys.length) {
        if (f(Caml_array.get(xs, i), Caml_array.get(ys, j))) {
          Caml_array.set(result, k, Caml_array.get(xs, i));
          _k = k + 1 | 0;
          _i = i + 1 | 0;
          continue ;
        }
        Caml_array.set(result, k, Caml_array.get(ys, j));
        _k = k + 1 | 0;
        _j = j + 1 | 0;
        continue ;
      }
      if (i < xs.length) {
        Caml_array.set(result, k, Caml_array.get(xs, i));
        _k = k + 1 | 0;
        _i = i + 1 | 0;
        continue ;
      }
      if (j >= ys.length) {
        return ;
      }
      Caml_array.set(result, k, Caml_array.get(ys, j));
      _k = k + 1 | 0;
      _j = j + 1 | 0;
      continue ;
    };
  };
  loop(0, 0, 0);
  return result;
}

function setIndexImmutable(arr, index, value) {
  var shallowCopy = arr.slice(0);
  shallowCopy[index] = value;
  return shallowCopy;
}

function transposeResults(results) {
  var _index = 0;
  var output = new Array(results.length);
  while(true) {
    var index = _index;
    if (index >= results.length) {
      return {
              TAG: "Ok",
              _0: output
            };
    }
    var value = results[index];
    if (value.TAG !== "Ok") {
      return value;
    }
    Caml_array.set(output, index, value._0);
    _index = index + 1 | 0;
    continue ;
  };
}

function includes(arr, val) {
  return Belt_Option.isSome(Caml_option.undefined_to_opt(arr.find(function (item) {
                      return Caml_obj.equal(item, val);
                    })));
}

function isEmpty(arr) {
  return arr.length === 0;
}

function notEmpty(arr) {
  return arr.length !== 0;
}

async function awaitEach(arr, fn) {
  for(var i = 0 ,i_finish = arr.length; i < i_finish; ++i){
    var item = Caml_array.get(arr, i);
    await fn(item);
  }
}

function removeAtIndex(array, index) {
  if (index < 0) {
    return $$Array.copy(array);
  } else {
    return array.slice(0, index).concat(array.slice(index + 1 | 0));
  }
}

function last(arr) {
  return Belt_Array.get(arr, arr.length - 1 | 0);
}

function findReverseWithIndex(arr, fn) {
  var _index = arr.length - 1 | 0;
  while(true) {
    var index = _index;
    if (index < 0) {
      return ;
    }
    var item = Caml_array.get(arr, index);
    if (fn(item)) {
      return [
              item,
              index
            ];
    }
    _index = index - 1 | 0;
    continue ;
  };
}

function interleave(arr, separator) {
  var interleaved = [];
  arr.forEach(function (v, i) {
        interleaved.push(v);
        if (i < (arr.length - 1 | 0)) {
          interleaved.push(separator);
          return ;
        }
        
      });
  return interleaved;
}

var $$Array$1 = {
  mergeSorted: mergeSorted,
  setIndexImmutable: setIndexImmutable,
  transposeResults: transposeResults,
  includes: includes,
  isEmpty: isEmpty,
  notEmpty: notEmpty,
  awaitEach: awaitEach,
  removeAtIndex: removeAtIndex,
  last: last,
  findReverseWithIndex: findReverseWithIndex,
  interleave: interleave
};

function capitalize(str) {
  return str.slice(0, 1).toUpperCase() + str.slice(1);
}

var $$String = {
  capitalize: capitalize
};

function forEach$1(result, fn) {
  if (result.TAG === "Ok") {
    fn(result._0);
  }
  return result;
}

var Result = {
  forEach: forEach$1
};

function unwrapResultExn(res) {
  if (res.TAG === "Ok") {
    return res._0;
  }
  throw res._0;
}

var variantTag = S$RescriptSchema.union([
      S$RescriptSchema.string,
      S$RescriptSchema.object(function (s) {
            return s.f("TAG", S$RescriptSchema.string);
          })
    ]);

function getNonOptionalFieldNames(schema) {
  var acc = [];
  var match = schema.t;
  if (typeof match === "object" && match.TAG === "object") {
    match.items.forEach(function (item) {
          var match = item.schema.t;
          if (typeof match !== "object") {
            acc.push(item.location);
            return ;
          }
          switch (match.TAG) {
            case "option" :
            case "null" :
                return ;
            default:
              acc.push(item.location);
              return ;
          }
        });
  }
  return acc;
}

function getCapitalizedFieldNames(schema) {
  var match = schema.t;
  if (typeof match !== "object") {
    return [];
  } else if (match.TAG === "object") {
    return match.items.map(function (item) {
                return capitalize(item.location);
              });
  } else {
    return [];
  }
}

var dbDate = S$RescriptSchema.preprocess(S$RescriptSchema.json(false), (function (param) {
        return {
                s: (function (date) {
                    return date.toISOString();
                  })
              };
      }));

function coerceToJsonPgType(schema) {
  return S$RescriptSchema.preprocess(schema, (function (s) {
                var match = s.schema.t;
                if (typeof match === "object") {
                  return {};
                }
                switch (match) {
                  case "unknown" :
                      return {
                              s: (function (param) {
                                  return "null";
                                })
                            };
                  case "boolean" :
                      return {
                              s: (function (unknown) {
                                  if (unknown === false) {
                                    return "false";
                                  } else if (unknown === true) {
                                    return "true";
                                  } else {
                                    return unknown;
                                  }
                                })
                            };
                  default:
                    return {};
                }
              }));
}

var Schema = {
  variantTag: variantTag,
  getNonOptionalFieldNames: getNonOptionalFieldNames,
  getCapitalizedFieldNames: getCapitalizedFieldNames,
  dbDate: dbDate,
  coerceToJsonPgType: coerceToJsonPgType
};

function getVariantsTags(variants) {
  return variants.map(function (variant) {
              return S$RescriptSchema.parseOrThrow(variant, variantTag);
            });
}

function addMany(set, values) {
  values.forEach(function (value) {
        set.add(value);
      });
}

var $$Set = {
  addMany: addMany
};

var $$WeakMap = {};

var $$Map = {};

var $$Proxy = {};

function fail(name) {
  return Js_exn.raiseError("Failed to get hash for " + name + ". If you're using a custom Sury schema make it based on the string type with a decoder: const myTypeSchema = S.transform(S.string, undefined, (yourType) => yourType.toString())");
}

function makeOrThrow(any) {
  var $$typeof = typeof any;
  switch ($$typeof) {
    case "bigint" :
        return "\"" + any.toString() + "\"";
    case "boolean" :
        if (any) {
          return "true";
        } else {
          return "false";
        }
    case "number" :
        return any.toString();
    case "object" :
        if (any === null) {
          return "null";
        }
        if (Array.isArray(any)) {
          var hash = "[";
          for(var i = 0 ,i_finish = any.length; i < i_finish; ++i){
            if (i !== 0) {
              hash = hash + ",";
            }
            hash = hash + makeOrThrow(any[i]);
          }
          return hash + "]";
        }
        var constructor = any["constructor"];
        if (constructor !== Object) {
          if (constructor.name === "BigNumber") {
            return "\"" + any.toString() + "\"";
          } else {
            return fail(constructor.name);
          }
        }
        var hash$1 = "{";
        var keys = Object.keys(any).sort();
        var isFirst = true;
        for(var i$1 = 0 ,i_finish$1 = keys.length; i$1 < i_finish$1; ++i$1){
          var key = keys[i$1];
          var value = any[key];
          if (value !== undefined) {
            if (isFirst) {
              isFirst = false;
            } else {
              hash$1 = hash$1 + ",";
            }
            hash$1 = hash$1 + ("\"" + key + "\":" + makeOrThrow(any[key]));
          }
          
        }
        return hash$1 + "}";
    case "string" :
        return "\"" + any + "\"";
    case "function" :
    case "symbol" :
        return any.toString();
    case "undefined" :
        return "null";
    default:
      return fail($$typeof);
  }
}

var Hash = {
  fail: fail,
  makeOrThrow: makeOrThrow
};

exports.delay = delay;
exports.$$Object = $$Object;
exports.$$Error = $$Error;
exports.$$Option = $$Option;
exports.Tuple = Tuple;
exports.Dict = Dict;
exports.$$Math = $$Math;
exports.$$Array = $$Array$1;
exports.$$String = $$String;
exports.Result = Result;
exports.unwrapResultExn = unwrapResultExn;
exports.Schema = Schema;
exports.getVariantsTags = getVariantsTags;
exports.$$Set = $$Set;
exports.$$WeakMap = $$WeakMap;
exports.$$Map = $$Map;
exports.$$Proxy = $$Proxy;
exports.Hash = Hash;
/* variantTag Not a pure module */
