// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Time = require("../Time.res.js");
var Logging = require("../Logging.res.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var HyperFuelClient = require("./HyperFuelClient.res.js");
var S$RescriptSchema = require("rescript-schema/src/S.res.js");

var cache = {};

function getClient(url) {
  var client = cache[url];
  if (client !== undefined) {
    return Caml_option.valFromOption(client);
  }
  var newClient = HyperFuelClient.make({
        url: url
      });
  cache[url] = newClient;
  return newClient;
}

function queryErrorToMsq(e) {
  var match = e._0;
  return match.queryName + " query failed due to unexpected missing params on response:\n      " + match.missingParams.join(", ");
}

var $$Error = /* @__PURE__ */Caml_exceptions.create("HyperFuel.GetLogs.Error");

function makeRequestBody(fromBlock, toBlockInclusive, recieptsSelection) {
  return {
          fromBlock: fromBlock,
          toBlock: toBlockInclusive !== undefined ? toBlockInclusive + 1 | 0 : undefined,
          receipts: recieptsSelection,
          fieldSelection: {
            block: [
              "id",
              "height",
              "time"
            ],
            receipt: [
              "tx_id",
              "block_height",
              "root_contract_id",
              "data",
              "receipt_index",
              "receipt_type",
              "rb",
              "sub_id",
              "val",
              "amount",
              "to_address",
              "asset_id",
              "to"
            ]
          }
        };
}

function getParam(param, name) {
  if (param !== undefined) {
    return Caml_option.valFromOption(param);
  }
  throw {
        RE_EXN_ID: $$Error,
        _1: {
          TAG: "UnexpectedMissingParams",
          missingParams: [name]
        },
        Error: new Error()
      };
}

function decodeLogQueryPageItems(response_data) {
  var blocksDict = {};
  Belt_Array.forEach(response_data.blocks, (function (block) {
          blocksDict[block.height] = block;
        }));
  var items = [];
  Belt_Array.forEach(response_data.receipts, (function (receipt) {
          var contractId = receipt.rootContractId;
          if (contractId === undefined) {
            return ;
          }
          var block = getParam(blocksDict[receipt.blockHeight], "Failed to find block associated to receipt");
          items.push({
                transactionId: receipt.txId,
                contractId: Caml_option.valFromOption(contractId),
                receipt: receipt,
                receiptIndex: receipt.receiptIndex,
                block: {
                  id: block.id,
                  time: block.time,
                  height: block.height
                }
              });
        }));
  return items;
}

async function query(serverUrl, fromBlock, toBlock, recieptsSelection) {
  var query$1 = makeRequestBody(fromBlock, toBlock, recieptsSelection);
  var hyperFuelClient = getClient(serverUrl);
  var res = await hyperFuelClient.getSelectedData(query$1);
  if (res.nextBlock <= fromBlock) {
    throw {
          RE_EXN_ID: $$Error,
          _1: "WrongInstance",
          Error: new Error()
        };
  }
  return {
          items: decodeLogQueryPageItems(res.data),
          nextBlock: res.nextBlock,
          archiveHeight: Belt_Option.getWithDefault(res.archiveHeight, 0)
        };
}

async function queryBlockData(serverUrl, blockNumber, logger) {
  var query_toBlock = blockNumber + 1 | 0;
  var query_inputs = [{}];
  var query_outputs = [{}];
  var query_includeAllBlocks = true;
  var query_fieldSelection = {
    block: [
      "height",
      "id",
      "time"
    ]
  };
  var query = {
    fromBlock: blockNumber,
    toBlock: query_toBlock,
    inputs: query_inputs,
    outputs: query_outputs,
    includeAllBlocks: query_includeAllBlocks,
    fieldSelection: query_fieldSelection
  };
  var hyperFuelClient = getClient(serverUrl);
  var logger$1 = Logging.createChildFrom(logger, {
        logType: "hypersync get blockhash query",
        blockNumber: blockNumber
      });
  var executeQuery = function () {
    return hyperFuelClient.getSelectedData(query);
  };
  var res = await Time.retryAsyncWithExponentialBackOff(undefined, undefined, undefined, undefined, logger$1, executeQuery);
  if (res.nextBlock > blockNumber) {
    return Belt_Option.flatMap(res.data.blocks, (function (blocks) {
                  return Belt_Option.map(Belt_Array.get(blocks, 0), (function (block) {
                                return {
                                        blockHash: block.id,
                                        blockNumber: block.height,
                                        blockTimestamp: block.time
                                      };
                              }));
                }));
  }
  var logger$2 = Logging.createChild({
        url: serverUrl
      });
  Logging.childInfo(logger$2, "Block #" + String(blockNumber) + " not found in HyperFuel. HyperFuel has multiple instances and it's possible that they drift independently slightly from the head. Indexing should continue correctly after retrying the query in " + String(100) + "ms.");
  await Time.resolvePromiseAfterDelay(100);
  return await queryBlockData(serverUrl, blockNumber, logger$2);
}

function heightRoute() {
  return {
          method: "GET",
          path: "/height",
          input: (function (param) {
              
            }),
          responses: [(function (s) {
                return s.field("height", S$RescriptSchema.$$int);
              })]
        };
}

var GetLogs = {
  $$Error: $$Error,
  query: query
};

exports.queryErrorToMsq = queryErrorToMsq;
exports.GetLogs = GetLogs;
exports.queryBlockData = queryBlockData;
exports.heightRoute = heightRoute;
/* Time Not a pure module */
