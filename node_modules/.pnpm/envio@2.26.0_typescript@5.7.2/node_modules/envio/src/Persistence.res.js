// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require("rescript/lib/js/js_exn.js");
var Logging = require("./Logging.res.js");
var Prometheus = require("./Prometheus.res.js");
var EntityHistory = require("./db/EntityHistory.res.js");
var ErrorHandling = require("./ErrorHandling.res.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var StorageError = /* @__PURE__ */Caml_exceptions.create("Persistence.StorageError");

var entityHistoryActionEnumConfig_name = EntityHistory.RowAction.name;

var entityHistoryActionEnumConfig_variants = EntityHistory.RowAction.variants;

var entityHistoryActionEnumConfig_schema = EntityHistory.RowAction.schema;

var entityHistoryActionEnumConfig = {
  name: entityHistoryActionEnumConfig_name,
  variants: entityHistoryActionEnumConfig_variants,
  schema: entityHistoryActionEnumConfig_schema,
  default: "SET"
};

function make(userEntities, dcRegistryEntityConfig, allEnums, staticTables, storage) {
  var allEntities = userEntities.concat([dcRegistryEntityConfig]);
  var allEnums$1 = allEnums.concat([entityHistoryActionEnumConfig]);
  return {
          userEntities: userEntities,
          staticTables: staticTables,
          allEntities: allEntities,
          allEnums: allEnums$1,
          storageStatus: "Unknown",
          storage: storage
        };
}

async function loadInitialCache(persistence, withUpload) {
  var effectCacheRecords = await persistence.storage.restoreEffectCache(withUpload);
  var cache = {};
  effectCacheRecords.forEach(function (record) {
        Prometheus.EffectCacheCount.set(record.count, record.effectName);
        cache[record.effectName] = record;
      });
  return cache;
}

async function init(persistence, resetOpt) {
  var reset = resetOpt !== undefined ? resetOpt : false;
  try {
    var promise = persistence.storageStatus;
    var shouldRun;
    if (typeof promise !== "object") {
      shouldRun = true;
    } else if (promise.TAG === "Initializing") {
      await promise._0;
      shouldRun = reset;
    } else {
      shouldRun = reset;
    }
    if (!shouldRun) {
      return ;
    }
    var resolveRef = {
      contents: null
    };
    var promise$1 = new Promise((function (resolve, param) {
            resolveRef.contents = resolve;
          }));
    persistence.storageStatus = {
      TAG: "Initializing",
      _0: promise$1
    };
    if (reset || !await persistence.storage.isInitialized()) {
      Logging.info("Initializing the indexer storage...");
      await persistence.storage.initialize(persistence.allEntities, persistence.staticTables, persistence.allEnums);
      Logging.info("The indexer storage is ready. Uploading cache...");
      persistence.storageStatus = {
        TAG: "Ready",
        cleanRun: true,
        cache: await loadInitialCache(persistence, true)
      };
    } else {
      var match = persistence.storageStatus;
      var tmp;
      tmp = typeof match !== "object" || match.TAG !== "Initializing" ? false : true;
      if (tmp) {
        Logging.info("The indexer storage is ready.");
        persistence.storageStatus = {
          TAG: "Ready",
          cleanRun: false,
          cache: await loadInitialCache(persistence, false)
        };
      }
      
    }
    return resolveRef.contents();
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return ErrorHandling.mkLogAndRaise(undefined, "EE800: Failed to initialize the indexer storage.", exn);
  }
}

function getInitializedStorageOrThrow(persistence) {
  var match = persistence.storageStatus;
  if (typeof match !== "object" || match.TAG === "Initializing") {
    return Js_exn.raiseError("Failed to access the indexer storage. The Persistence layer is not initialized.");
  } else {
    return persistence.storage;
  }
}

async function setEffectCacheOrThrow(persistence, effect, items) {
  var match = persistence.storageStatus;
  if (typeof match !== "object") {
    return Js_exn.raiseError("Failed to access the indexer storage. The Persistence layer is not initialized.");
  }
  if (match.TAG === "Initializing") {
    return Js_exn.raiseError("Failed to access the indexer storage. The Persistence layer is not initialized.");
  }
  var cache = match.cache;
  var storage = persistence.storage;
  var effectName = effect.name;
  var c = cache[effectName];
  var effectCacheRecord;
  if (c !== undefined) {
    effectCacheRecord = c;
  } else {
    var c$1 = {
      effectName: effectName,
      count: 0
    };
    cache[effectName] = c$1;
    effectCacheRecord = c$1;
  }
  var initialize = effectCacheRecord.count === 0;
  await storage.setEffectCacheOrThrow(effect, items, initialize);
  effectCacheRecord.count = effectCacheRecord.count + items.length | 0;
  return Prometheus.EffectCacheCount.set(effectCacheRecord.count, effectName);
}

exports.StorageError = StorageError;
exports.entityHistoryActionEnumConfig = entityHistoryActionEnumConfig;
exports.make = make;
exports.init = init;
exports.getInitializedStorageOrThrow = getInitializedStorageOrThrow;
exports.setEffectCacheOrThrow = setEffectCacheOrThrow;
/* Logging Not a pure module */
