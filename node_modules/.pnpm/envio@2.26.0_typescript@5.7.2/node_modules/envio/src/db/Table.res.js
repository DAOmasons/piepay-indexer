// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$BigInt = require("../bindings/BigInt.res.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Belt_SetString = require("rescript/lib/js/belt_SetString.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var S$RescriptSchema = require("rescript-schema/src/S.res.js");

function mkField(fieldName, fieldType, fieldSchema, $$default, isArrayOpt, isNullableOpt, isPrimaryKeyOpt, isIndexOpt, linkedEntity) {
  var isArray = isArrayOpt !== undefined ? isArrayOpt : false;
  var isNullable = isNullableOpt !== undefined ? isNullableOpt : false;
  var isPrimaryKey = isPrimaryKeyOpt !== undefined ? isPrimaryKeyOpt : false;
  var isIndex = isIndexOpt !== undefined ? isIndexOpt : false;
  return {
          TAG: "Field",
          _0: {
            fieldName: fieldName,
            fieldType: fieldType,
            fieldSchema: fieldSchema,
            isArray: isArray,
            isNullable: isNullable,
            isPrimaryKey: isPrimaryKey,
            isIndex: isIndex,
            linkedEntity: linkedEntity,
            defaultValue: $$default
          }
        };
}

function mkDerivedFromField(fieldName, derivedFromEntity, derivedFromField) {
  return {
          TAG: "DerivedFrom",
          _0: {
            fieldName: fieldName,
            derivedFromEntity: derivedFromEntity,
            derivedFromField: derivedFromField
          }
        };
}

function getUserDefinedFieldName(fieldOrDerived) {
  return fieldOrDerived._0.fieldName;
}

function isLinkedEntityField(field) {
  return Belt_Option.isSome(field.linkedEntity);
}

function getDbFieldName(field) {
  if (Belt_Option.isSome(field.linkedEntity)) {
    return field.fieldName + "_id";
  } else {
    return field.fieldName;
  }
}

function getFieldName(fieldOrDerived) {
  if (fieldOrDerived.TAG === "Field") {
    return getDbFieldName(fieldOrDerived._0);
  } else {
    return fieldOrDerived._0.fieldName;
  }
}

function getFieldType(field) {
  return field.fieldType + (
          field.isArray ? "[]" : ""
        );
}

function mkTable(tableName, compositeIndicesOpt, fields) {
  var compositeIndices = compositeIndicesOpt !== undefined ? compositeIndicesOpt : [];
  return {
          tableName: tableName,
          fields: fields,
          compositeIndices: compositeIndices
        };
}

function getPrimaryKeyFieldNames(table) {
  return Belt_Array.keepMap(table.fields, (function (field) {
                if (field.TAG !== "Field") {
                  return ;
                }
                var match = field._0;
                if (match.isPrimaryKey) {
                  return match.fieldName;
                }
                
              }));
}

function getFields(table) {
  return Belt_Array.keepMap(table.fields, (function (field) {
                if (field.TAG === "Field") {
                  return field._0;
                }
                
              }));
}

function getFieldNames(table) {
  return Belt_Array.map(getFields(table), getDbFieldName);
}

function getNonDefaultFields(table) {
  return Belt_Array.keepMap(table.fields, (function (field) {
                if (field.TAG !== "Field") {
                  return ;
                }
                var field$1 = field._0;
                if (Belt_Option.isNone(field$1.defaultValue)) {
                  return field$1;
                }
                
              }));
}

function getLinkedEntityFields(table) {
  return Belt_Array.keepMap(table.fields, (function (field) {
                if (field.TAG !== "Field") {
                  return ;
                }
                var field$1 = field._0;
                var linkedEntityName = field$1.linkedEntity;
                if (linkedEntityName !== undefined) {
                  return [
                          field$1,
                          linkedEntityName
                        ];
                }
                
              }));
}

function getDerivedFromFields(table) {
  return Belt_Array.keepMap(table.fields, (function (field) {
                if (field.TAG === "Field") {
                  return ;
                } else {
                  return field._0;
                }
              }));
}

function getNonDefaultFieldNames(table) {
  return Belt_Array.map(getNonDefaultFields(table), getDbFieldName);
}

function getFieldByName(table, fieldName) {
  return Caml_option.undefined_to_opt(table.fields.find(function (field) {
                  return field._0.fieldName === fieldName;
                }));
}

function getFieldByDbName(table, dbFieldName) {
  return Caml_option.undefined_to_opt(table.fields.find(function (field) {
                  var tmp;
                  tmp = field.TAG === "Field" ? getDbFieldName(field._0) : field._0.fieldName;
                  return tmp === dbFieldName;
                }));
}

var NonExistingTableField = /* @__PURE__ */Caml_exceptions.create("Table.NonExistingTableField");

function getUnfilteredCompositeIndicesUnsafe(table) {
  return Belt_Array.map(table.compositeIndices, (function (compositeIndex) {
                return Belt_Array.map(compositeIndex, (function (userDefinedFieldName) {
                              var field = getFieldByName(table, userDefinedFieldName);
                              if (field !== undefined) {
                                return getFieldName(field);
                              }
                              throw {
                                    RE_EXN_ID: NonExistingTableField,
                                    _1: userDefinedFieldName,
                                    Error: new Error()
                                  };
                            }));
              }));
}

function toSqlParams(table, schema, pgSchema) {
  var quotedFieldNames = [];
  var quotedNonPrimaryFieldNames = [];
  var arrayFieldTypes = [];
  var hasArrayField = {
    contents: false
  };
  var dbSchema = S$RescriptSchema.schema(function (s) {
        var match = schema.t;
        if (typeof match !== "object") {
          return Js_exn.raiseError("Failed creating db schema. Expected an object schema for table");
        }
        if (match.TAG !== "object") {
          return Js_exn.raiseError("Failed creating db schema. Expected an object schema for table");
        }
        var dict = {};
        Belt_Array.forEach(match.items, (function (param) {
                var inlinedLocation = param.inlinedLocation;
                var $$location = param.location;
                var coerceSchema = function (schema) {
                  var child = schema.t;
                  if (typeof child !== "object") {
                    switch (child) {
                      case "bigint" :
                          return $$BigInt.schema;
                      case "boolean" :
                          return S$RescriptSchema.union([
                                      S$RescriptSchema.shape(S$RescriptSchema.literal(1), (function (param) {
                                              return true;
                                            })),
                                      S$RescriptSchema.shape(S$RescriptSchema.literal(0), (function (param) {
                                              return false;
                                            }))
                                    ]);
                      default:
                        return schema;
                    }
                  } else {
                    switch (child.TAG) {
                      case "option" :
                      case "null" :
                          return S$RescriptSchema.$$null(coerceSchema(child._0));
                      case "array" :
                          hasArrayField.contents = true;
                          return S$RescriptSchema.array(coerceSchema(child._0));
                      case "JSON" :
                          hasArrayField.contents = true;
                          return schema;
                      default:
                        return schema;
                    }
                  }
                };
                var field = getFieldByDbName(table, $$location);
                var field$1;
                if (field !== undefined) {
                  field$1 = field;
                } else {
                  throw {
                        RE_EXN_ID: NonExistingTableField,
                        _1: $$location,
                        Error: new Error()
                      };
                }
                quotedFieldNames.push(inlinedLocation);
                if (field$1.TAG === "Field") {
                  if (field$1._0.isPrimaryKey) {
                    
                  } else {
                    quotedNonPrimaryFieldNames.push(inlinedLocation);
                  }
                }
                var tmp;
                if (field$1.TAG === "Field") {
                  var f = field$1._0;
                  var fieldType = f.fieldType;
                  tmp = fieldType === "TIMESTAMP" || fieldType === "TIMESTAMP WITH TIME ZONE" || fieldType === "JSONB" || fieldType === "SERIAL" || fieldType === "TEXT" || fieldType === "DOUBLE PRECISION" || fieldType === "NUMERIC" || fieldType === "BOOLEAN" || fieldType === "INTEGER" || fieldType === "TIMESTAMP WITH TIME ZONE NULL" ? (
                      fieldType === "BOOLEAN" ? "INTEGER[]::" + f.fieldType : fieldType
                    ) : "TEXT[]::\"" + pgSchema + "\"." + fieldType;
                } else {
                  tmp = "TEXT";
                }
                arrayFieldTypes.push(tmp + "[]");
                dict[$$location] = s.m(coerceSchema(param.schema));
              }));
        return dict;
      });
  return {
          dbSchema: dbSchema,
          quotedFieldNames: quotedFieldNames,
          quotedNonPrimaryFieldNames: quotedNonPrimaryFieldNames,
          arrayFieldTypes: arrayFieldTypes,
          hasArrayField: hasArrayField.contents
        };
}

function getSingleIndices(table) {
  var indexFields = Belt_Array.keepMap(table.fields, (function (field) {
          if (field.TAG !== "Field") {
            return ;
          }
          var field$1 = field._0;
          if (field$1.isIndex) {
            return getDbFieldName(field$1);
          }
          
        }));
  return Belt_SetString.toArray(Belt_SetString.fromArray(Belt_Array.concatMany(Belt_Array.concat(Belt_Array.keep(getUnfilteredCompositeIndicesUnsafe(table), (function (cidx) {
                                  return cidx.length === 1;
                                })), [indexFields])))).sort();
}

function getCompositeIndices(table) {
  return Belt_Array.keep(getUnfilteredCompositeIndicesUnsafe(table), (function (ind) {
                return ind.length > 1;
              }));
}

exports.mkField = mkField;
exports.mkDerivedFromField = mkDerivedFromField;
exports.getUserDefinedFieldName = getUserDefinedFieldName;
exports.isLinkedEntityField = isLinkedEntityField;
exports.getDbFieldName = getDbFieldName;
exports.getFieldName = getFieldName;
exports.getFieldType = getFieldType;
exports.mkTable = mkTable;
exports.getPrimaryKeyFieldNames = getPrimaryKeyFieldNames;
exports.getFields = getFields;
exports.getFieldNames = getFieldNames;
exports.getNonDefaultFields = getNonDefaultFields;
exports.getLinkedEntityFields = getLinkedEntityFields;
exports.getDerivedFromFields = getDerivedFromFields;
exports.getNonDefaultFieldNames = getNonDefaultFieldNames;
exports.getFieldByName = getFieldByName;
exports.getFieldByDbName = getFieldByDbName;
exports.NonExistingTableField = NonExistingTableField;
exports.getUnfilteredCompositeIndicesUnsafe = getUnfilteredCompositeIndicesUnsafe;
exports.toSqlParams = toSqlParams;
exports.getSingleIndices = getSingleIndices;
exports.getCompositeIndices = getCompositeIndices;
/* BigInt Not a pure module */
